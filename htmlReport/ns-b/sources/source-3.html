


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > AnniversaryParserUtils</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">seedu.address.logic.parser</a>
</div>

<h1>Coverage Summary for Class: AnniversaryParserUtils (seedu.address.logic.parser)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">AnniversaryParserUtils</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    81.8%
  </span>
  <span class="absValue">
    (9/11)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    87.5%
  </span>
  <span class="absValue">
    (21/24)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    96.4%
  </span>
  <span class="absValue">
    (54/56)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package seedu.address.logic.parser;
&nbsp;
&nbsp;import static java.util.Objects.requireNonNull;
&nbsp;import static seedu.address.logic.Messages.MESSAGE_INVALID_COMMAND_FORMAT;
&nbsp;import static seedu.address.logic.parser.CliSyntax.PREFIX_ANNIVERSARY_DATE;
&nbsp;import static seedu.address.logic.parser.CliSyntax.PREFIX_ANNIVERSARY_DESC;
&nbsp;import static seedu.address.logic.parser.CliSyntax.PREFIX_ANNIVERSARY_NAME;
&nbsp;import static seedu.address.logic.parser.CliSyntax.PREFIX_ANNIVERSARY_TYPE;
&nbsp;import static seedu.address.logic.parser.CliSyntax.PREFIX_ANNIVERSARY_TYPE_DESC;
&nbsp;import static seedu.address.logic.parser.CliSyntax.PREFIX_BIRTHDAY;
&nbsp;import static seedu.address.logic.parser.CliSyntax.PREFIX_NAME;
&nbsp;import static seedu.address.logic.parser.CliSyntax.PREFIX_WORK_ANNIVERSARY;
&nbsp;import static seedu.address.logic.parser.ParserUtil.validateSafeContent;
&nbsp;
&nbsp;import java.time.LocalDate;
&nbsp;import java.time.format.DateTimeParseException;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.List;
&nbsp;import java.util.stream.Stream;
&nbsp;
&nbsp;import seedu.address.logic.parser.exceptions.ParseException;
&nbsp;import seedu.address.model.anniversary.Anniversary;
&nbsp;import seedu.address.model.anniversary.AnniversaryType;
&nbsp;import seedu.address.model.anniversary.Birthday;
&nbsp;import seedu.address.model.anniversary.WorkAnniversary;
&nbsp;import seedu.address.model.person.Name;
&nbsp;
&nbsp;/**
&nbsp; * Utility class for parsing different kinds of anniversary information.
&nbsp; */
<b class="nc">&nbsp;public class AnniversaryParserUtils {</b>
&nbsp;    /** Error message if required anniversary fields are missing. */
&nbsp;    public static final String INVALID_ANNIVERSARY = &quot;Anniversary must include the following&quot;
&nbsp;            + &quot; prefixes: an/NAME d/DATE at/type ad/description atdesc/typeDescription&quot;
&nbsp;            + &quot; or bd/ for BIRTHDAY or wa/ for WORK_ANNIVERSARY&quot;;
&nbsp;    /** Error message if the date format is invalid. */
&nbsp;    public static final String MESSAGE_DATE_CONSTRAINTS = &quot;Anniversary date must be in YYYY-MM-DD format.&quot;;
&nbsp;
&nbsp;    /**
&nbsp;     * Parses anniversary-related fields from the given `ArgumentMultimap`.
&nbsp;     * Throws `ParseException` if the fields are invalid.
&nbsp;     *
&nbsp;     * @param argMultimap Contains user arguments.
&nbsp;     * @return A valid `Anniversary`.
&nbsp;     * @throws ParseException If arguments are not properly formatted.
&nbsp;     */
&nbsp;    public static Anniversary resolveAnniversaryInput(ArgumentMultimap argMultimap) throws ParseException {
<b class="fc">&nbsp;        boolean hasAnnivType = arePresent(argMultimap, PREFIX_ANNIVERSARY_NAME, PREFIX_ANNIVERSARY_TYPE);</b>
<b class="fc">&nbsp;        boolean hasBirthday = arePresent(argMultimap, PREFIX_BIRTHDAY, PREFIX_NAME);</b>
<b class="fc">&nbsp;        boolean hasWork = argMultimap.getValue(PREFIX_WORK_ANNIVERSARY).isPresent();</b>
&nbsp;
<b class="pc">&nbsp;        if (hasAnnivType &amp;&amp; (hasBirthday || hasWork)) {</b>
<b class="fc">&nbsp;            throw new ParseException(errorMsg());</b>
&nbsp;        }
<b class="fc">&nbsp;        if (hasAnnivType) {</b>
<b class="fc">&nbsp;            return parseStandardAnniversary(argMultimap);</b>
&nbsp;        }
<b class="fc">&nbsp;        if (hasBirthday) {</b>
<b class="fc">&nbsp;            return parseBirthday(argMultimap);</b>
&nbsp;        }
<b class="fc">&nbsp;        if (hasWork) {</b>
<b class="fc">&nbsp;            return parseWorkAnniversary(argMultimap);</b>
&nbsp;        }
<b class="fc">&nbsp;        throw new ParseException(errorMsg());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Parses multiple anniversaries from the given `ArgumentMultimap`.
&nbsp;     *
&nbsp;     * @param argMultimap Contains user arguments.
&nbsp;     * @return A list of valid `Anniversary` objects.
&nbsp;     * @throws ParseException If arguments are invalid.
&nbsp;     */
&nbsp;    public static List&lt;Anniversary&gt; multiAddAnniversary(ArgumentMultimap argMultimap) throws ParseException {
<b class="fc">&nbsp;        List&lt;Anniversary&gt; anniversaries = new ArrayList&lt;&gt;();</b>
<b class="pc">&nbsp;        if (arePresent(argMultimap, PREFIX_BIRTHDAY, PREFIX_NAME)) {</b>
<b class="fc">&nbsp;            anniversaries.add(parseBirthday(argMultimap));</b>
&nbsp;        }
<b class="fc">&nbsp;        if (argMultimap.getValue(PREFIX_WORK_ANNIVERSARY).isPresent()) {</b>
<b class="fc">&nbsp;            anniversaries.add(parseWorkAnniversary(argMultimap));</b>
&nbsp;        }
<b class="fc">&nbsp;        return anniversaries;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Parses a standard anniversary using well-known prefixes.
&nbsp;     *
&nbsp;     * @param argMultimap Contains user arguments.
&nbsp;     * @return A `Anniversary` with the required fields.
&nbsp;     * @throws ParseException If required fields are missing or invalid.
&nbsp;     */
&nbsp;    private static Anniversary parseStandardAnniversary(ArgumentMultimap argMultimap) throws ParseException {
<b class="fc">&nbsp;        String name = argMultimap.getValue(PREFIX_ANNIVERSARY_NAME).get();</b>
<b class="fc">&nbsp;        String desc = argMultimap.getValue(PREFIX_ANNIVERSARY_DESC).orElse(&quot;&quot;);</b>
<b class="fc">&nbsp;        String date = argMultimap.getValue(PREFIX_ANNIVERSARY_DATE).orElseThrow(() -&gt; new ParseException(dateMsg()));</b>
<b class="fc">&nbsp;        String type = argMultimap.getValue(PREFIX_ANNIVERSARY_TYPE).get();</b>
<b class="fc">&nbsp;        String typeDesc = argMultimap.getValue(PREFIX_ANNIVERSARY_TYPE_DESC).orElse(&quot;&quot;);</b>
<b class="fc">&nbsp;        return parseAnniversary(name, desc, date, type, typeDesc);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Parses a birthday anniversary.
&nbsp;     *
&nbsp;     * @param argMultimap Contains user arguments.
&nbsp;     * @return A `Anniversary` representing a birthday.
&nbsp;     * @throws ParseException If required fields are invalid.
&nbsp;     */
&nbsp;    private static Anniversary parseBirthday(ArgumentMultimap argMultimap) throws ParseException {
<b class="fc">&nbsp;        Name personName = ParserUtil.parseName(argMultimap.getValue(PREFIX_NAME).get());</b>
<b class="fc">&nbsp;        String date = argMultimap.getValue(PREFIX_BIRTHDAY).get();</b>
<b class="fc">&nbsp;        return parseAnniversaryWithName(personName, date, PREFIX_BIRTHDAY);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Parses a work anniversary.
&nbsp;     *
&nbsp;     * @param argMultimap Contains user arguments.
&nbsp;     * @return A `Anniversary` representing a work anniversary.
&nbsp;     * @throws ParseException If required fields are invalid.
&nbsp;     */
&nbsp;    private static Anniversary parseWorkAnniversary(ArgumentMultimap argMultimap) throws ParseException {
<b class="fc">&nbsp;        Name personName = ParserUtil.parseName(argMultimap.getValue(PREFIX_NAME).get());</b>
<b class="fc">&nbsp;        String date = argMultimap.getValue(PREFIX_WORK_ANNIVERSARY).get();</b>
<b class="fc">&nbsp;        return parseAnniversaryWithName(personName, date, PREFIX_WORK_ANNIVERSARY);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if all specified prefixes exist in the `ArgumentMultimap`.
&nbsp;     *
&nbsp;     * @param map The argument multimap to check.
&nbsp;     * @param prefixes Prefixes to verify.
&nbsp;     * @return True if all prefixes are present.
&nbsp;     */
&nbsp;    private static boolean arePresent(ArgumentMultimap map, Prefix... prefixes) {
<b class="fc">&nbsp;        return Stream.of(prefixes).allMatch(prefix -&gt; map.getValue(prefix).isPresent());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a standard error message related to anniversary fields.
&nbsp;     * @return A formatted error message.
&nbsp;     */
&nbsp;    private static String errorMsg() {
<b class="fc">&nbsp;        return String.format(MESSAGE_INVALID_COMMAND_FORMAT, INVALID_ANNIVERSARY);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a standard error message related to invalid date input.
&nbsp;     *
&nbsp;     * @return A formatted date error message.
&nbsp;     */
&nbsp;    private static String dateMsg() {
<b class="nc">&nbsp;        return String.format(MESSAGE_INVALID_COMMAND_FORMAT, MESSAGE_DATE_CONSTRAINTS);</b>
&nbsp;    }
&nbsp;    /**
&nbsp;     * Parses a {@code String name}, {@code String dateStr}, and a {@code String type} into an {@code Anniversary}.
&nbsp;     *
&nbsp;     * @param name the name of the anniversary for custom anniversaries
&nbsp;     * @param description the description of the anniversary
&nbsp;     * @param dateStr the date of the anniversary
&nbsp;     * @param type the type of the anniversary
&nbsp;     * @throws ParseException if the given {@code dateStr} is invalid.
&nbsp;     */
&nbsp;    public static Anniversary parseAnniversary(String name, String description, String dateStr, String type,
&nbsp;                                               String typeDescription) throws ParseException {
<b class="fc">&nbsp;        requireNonNull(dateStr);</b>
<b class="fc">&nbsp;        String trimmedAnniversaryDate = dateStr.trim();</b>
&nbsp;        LocalDate date;
&nbsp;        try {
<b class="fc">&nbsp;            validateSafeContent(name, &quot;anniversary name&quot;, true, true);</b>
<b class="fc">&nbsp;            validateSafeContent(type, &quot;anniversary type&quot;, false, false);</b>
<b class="fc">&nbsp;            validateSafeContent(description, &quot;anniversary description&quot;, false, true);</b>
<b class="fc">&nbsp;            date = LocalDate.parse(trimmedAnniversaryDate);</b>
<b class="fc">&nbsp;        } catch (DateTimeParseException e) {</b>
<b class="fc">&nbsp;            throw new ParseException(MESSAGE_DATE_CONSTRAINTS);</b>
&nbsp;        }
<b class="pc">&nbsp;        if (name == null || name.isEmpty()) {</b>
<b class="fc">&nbsp;            return new Anniversary(date, new AnniversaryType(type, typeDescription),</b>
&nbsp;                    description, type);
&nbsp;        } else {
<b class="fc">&nbsp;            return new Anniversary(date, new AnniversaryType(type, typeDescription),</b>
&nbsp;                    description, name);
&nbsp;        }
&nbsp;    }
&nbsp;    /**
&nbsp;     * Parses a {@code String name}, {@code String dateStr}, and a {@code String type} into an {@code Anniversary}.
&nbsp;     *
&nbsp;     * @param name the name of the person attributed to prebuilt-anniversaries
&nbsp;     * @param dateStr the date of the anniversary
&nbsp;     * @param type the prefix of the anniversary
&nbsp;     * @throws ParseException if the given {@code dateStr} is invalid.
&nbsp;     */
&nbsp;    public static Anniversary parseAnniversaryWithName(Name name, String dateStr,
&nbsp;                                                       Prefix type) throws ParseException {
<b class="fc">&nbsp;        String trimmedAnniversaryDate = dateStr.trim();</b>
&nbsp;        LocalDate date;
&nbsp;        try {
<b class="fc">&nbsp;            date = LocalDate.parse(trimmedAnniversaryDate);</b>
<b class="fc">&nbsp;        } catch (DateTimeParseException e) {</b>
<b class="fc">&nbsp;            throw new ParseException(MESSAGE_DATE_CONSTRAINTS);</b>
&nbsp;        }
<b class="fc">&nbsp;        if (type.equals(PREFIX_BIRTHDAY)) {</b>
<b class="fc">&nbsp;            String birthdayAppend = &quot;Birthday&quot;;</b>
<b class="fc">&nbsp;            return new Anniversary(date, new Birthday(), name + &quot;&#39;s &quot; + birthdayAppend, birthdayAppend);</b>
&nbsp;        }
<b class="fc">&nbsp;        if (type.equals(PREFIX_WORK_ANNIVERSARY)) {</b>
<b class="fc">&nbsp;            String workAnniversaryAppend = &quot;work anniversary&quot;;</b>
<b class="fc">&nbsp;            return new Anniversary(date, new WorkAnniversary(), name + &quot;&#39;s &quot;</b>
&nbsp;                    + workAnniversaryAppend, workAnniversaryAppend);
&nbsp;        }
<b class="fc">&nbsp;        throw new ParseException(&quot;Invalid anniversary type&quot;);</b>
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2025-04-03 01:00</div>
</div>
</body>
</html>
