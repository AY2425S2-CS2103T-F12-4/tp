


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > ImportCommand</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">seedu.address.logic.commands.importexport</a>
</div>

<h1>Coverage Summary for Class: ImportCommand (seedu.address.logic.commands.importexport)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">ImportCommand</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (11/11)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    93.3%
  </span>
  <span class="absValue">
    (28/30)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    90.5%
  </span>
  <span class="absValue">
    (95/105)
  </span>
</td>
</tr>
  <tr>
    <td class="name">ImportCommand$AggregationResult</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (12/12)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    93.3%
  </span>
  <span class="absValue">
    (28/30)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    90.8%
  </span>
  <span class="absValue">
    (99/109)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package seedu.address.logic.commands.importexport;
&nbsp;
&nbsp;import static seedu.address.logic.Messages.MESSAGE_MULTIPLE_EMPLOYEES_FOUND_WITH_PREFIX;
&nbsp;import static seedu.address.logic.parser.CliSyntax.PREFIX_FILEPATH;
&nbsp;import static seedu.address.logic.parser.CliSyntax.PREFIX_FILETYPE;
&nbsp;import static seedu.address.logic.parser.CliSyntax.PREFIX_WRITE_MODE;
&nbsp;
&nbsp;import java.io.IOException;
&nbsp;import java.nio.file.Path;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.HashSet;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.Set;
&nbsp;import java.util.logging.Logger;
&nbsp;import java.util.stream.Collectors;
&nbsp;
&nbsp;import javafx.util.Pair;
&nbsp;import lombok.Getter;
&nbsp;import seedu.address.commons.core.LogsCenter;
&nbsp;import seedu.address.commons.exceptions.DataLoadingException;
&nbsp;import seedu.address.commons.exceptions.IllegalValueException;
&nbsp;import seedu.address.logic.commands.Command;
&nbsp;import seedu.address.logic.commands.CommandResult;
&nbsp;import seedu.address.logic.commands.exceptions.CommandException;
&nbsp;import seedu.address.model.AddressBook;
&nbsp;import seedu.address.model.Model;
&nbsp;import seedu.address.model.person.Employee;
&nbsp;import seedu.address.model.person.EmployeeId;
&nbsp;import seedu.address.model.person.exceptions.DuplicatePersonException;
&nbsp;import seedu.address.model.util.EmployeeIdPrefixValidationUtils;
&nbsp;import seedu.address.storage.JsonAdaptedPerson;
&nbsp;import seedu.address.storage.JsonSerializableAddressBook;
&nbsp;import seedu.address.storage.PersonKey;
&nbsp;
&nbsp;/**
&nbsp; * Imports data from a file.
&nbsp; */
&nbsp;@Getter
&nbsp;public class ImportCommand extends Command {
&nbsp;    public static final String COMMAND_WORD = &quot;import&quot;;
<b class="fc">&nbsp;    public static final String MESSAGE_USAGE = &quot;import &quot;</b>
&nbsp;            + PREFIX_FILETYPE + &quot;&lt;json/csv&gt; &quot;
&nbsp;            + PREFIX_FILEPATH + &quot;&lt;fileName&gt; &quot;
&nbsp;            + PREFIX_FILEPATH + &quot;&lt;path&gt; &quot;
&nbsp;            + PREFIX_WRITE_MODE + &quot;&lt;append/overwrite&gt;&quot;;
&nbsp;    public static final String MESSAGE_SUCCESS_OVERWRITE = &quot;Successfully imported %d contacts,&quot;
&nbsp;            + &quot; overwriting existing data.&quot;;
&nbsp;    public static final String MESSAGE_SUCCESS_APPEND = &quot;&quot;&quot;
&nbsp;            Successfully imported %d contacts, skipped %d.\s
&nbsp;            Please resolve conflicts manually\s
&nbsp;             + %s&quot;&quot;&quot;;
&nbsp;    public static final String MESSAGE_INVALID_FILETYPE = &quot;Invalid filetype. Use &#39;json&#39; or &#39;csv&#39;.&quot;;
&nbsp;    public static final String MESSAGE_INVALID_MODE = &quot;Invalid mode. Use &#39;append&#39; or &#39;overwrite&#39;.&quot;;
&nbsp;    public static final String MESSAGE_INVALID_DATA = &quot;Invalid data in import file: %s&quot;;
<b class="fc">&nbsp;    private static final Logger logger = LogsCenter.getLogger(ImportCommand.class);</b>
&nbsp;    public final String filetype;
&nbsp;    public final Path path;
&nbsp;    public final String mode;
&nbsp;
&nbsp;    /**
&nbsp;     * Creates an ImportCommand to import the specified {@code Employee}
&nbsp;     *
&nbsp;     * @param filetype json or csv source file
&nbsp;     * @param path path to the file
&nbsp;     * @param mode append or replace
&nbsp;     */
<b class="fc">&nbsp;    public ImportCommand(String filetype, Path path, String mode) {</b>
<b class="fc">&nbsp;        this.filetype = filetype;</b>
<b class="fc">&nbsp;        this.path = path;</b>
<b class="fc">&nbsp;        this.mode = mode;</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    @Override
&nbsp;    public CommandResult execute(Model model) throws CommandException {
&nbsp;        try {
&nbsp;            // Import data from file
&nbsp;            JsonSerializableAddressBook importedData;
<b class="fc">&nbsp;            if (filetype.equalsIgnoreCase(&quot;json&quot;)) {</b>
<b class="fc">&nbsp;                importedData = AddressBookFormatConverter.importFromJson(path);</b>
<b class="fc">&nbsp;                logger.info(String.format(&quot;Importing from JSON + %s, %s&quot;, path, importedData));</b>
<b class="fc">&nbsp;            } else if (filetype.equalsIgnoreCase(&quot;csv&quot;)) {</b>
<b class="fc">&nbsp;                importedData = AddressBookFormatConverter.importFromCsv(path);</b>
<b class="fc">&nbsp;                logger.info(String.format(&quot;Importing from CSV + %s, %s&quot;, path, importedData));</b>
&nbsp;            } else {
<b class="fc">&nbsp;                throw new CommandException(MESSAGE_INVALID_FILETYPE);</b>
&nbsp;            }
&nbsp;
&nbsp;            // Handle different import modes
<b class="fc">&nbsp;            if (mode.equalsIgnoreCase(&quot;overwrite&quot;)) {</b>
<b class="fc">&nbsp;                return handleOverwriteMode(model, importedData);</b>
<b class="fc">&nbsp;            } else if (mode.equalsIgnoreCase(&quot;append&quot;)) {</b>
<b class="fc">&nbsp;                return handleAppendMode(model, importedData);</b>
&nbsp;            } else {
<b class="fc">&nbsp;                throw new CommandException(MESSAGE_INVALID_MODE);</b>
&nbsp;            }
<b class="fc">&nbsp;        } catch (IOException e) {</b>
<b class="fc">&nbsp;            throw new CommandException(&quot;Error reading file: &quot; + e.getMessage());</b>
<b class="nc">&nbsp;        } catch (DataLoadingException e) {</b>
<b class="nc">&nbsp;            throw new CommandException(&quot;Error loading data: &quot; + e.getMessage());</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * Handles the overwrite mode by replacing the entire address book.
&nbsp;     * Before overwriting, we aggregate the imported data and remove entries that have the same employeeId
&nbsp;     * but conflicting PersonKey details.
&nbsp;     * if there are EmployeeID prefix , it throws.
&nbsp;     */
&nbsp;    private CommandResult handleOverwriteMode(Model model, JsonSerializableAddressBook importedData)
&nbsp;            throws CommandException {
&nbsp;        try {
<b class="fc">&nbsp;            AggregationResult aggResult = aggregateImportedData(importedData);</b>
<b class="fc">&nbsp;            if (!aggResult.conflicts.isEmpty()) {</b>
<b class="fc">&nbsp;                String errorMessage = buildConflictErrorMessage(aggResult.conflicts);</b>
<b class="fc">&nbsp;                throw new CommandException(errorMessage);</b>
&nbsp;            }
&nbsp;            // Build a new AddressBook from the aggregated persons.
<b class="fc">&nbsp;            AddressBook newAddressBook = new AddressBook();</b>
<b class="fc">&nbsp;            for (Employee p : aggResult.aggregated) {</b>
<b class="fc">&nbsp;                newAddressBook.addPerson(p);</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            List&lt;Pair&lt;EmployeeId, EmployeeId&gt;&gt; conflictingPairs =</b>
<b class="fc">&nbsp;                    EmployeeIdPrefixValidationUtils.getPrefixConflictingPairs(newAddressBook.getEmployeeList());</b>
<b class="fc">&nbsp;            if (!conflictingPairs.isEmpty()) {</b>
<b class="fc">&nbsp;                throw new CommandException(String.format(MESSAGE_MULTIPLE_EMPLOYEES_FOUND_WITH_PREFIX,</b>
<b class="fc">&nbsp;                        conflictingPairs.get(0)));</b>
&nbsp;            }
<b class="fc">&nbsp;            model.setAddressBook(newAddressBook);</b>
<b class="fc">&nbsp;            int importedCount = newAddressBook.getEmployeeList().size();</b>
<b class="fc">&nbsp;            return new CommandResult(String.format(MESSAGE_SUCCESS_OVERWRITE, importedCount));</b>
<b class="nc">&nbsp;        } catch (IllegalValueException | DuplicatePersonException e) {</b>
<b class="nc">&nbsp;            throw new CommandException(String.format(MESSAGE_INVALID_DATA, e.getMessage()));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Handles the append mode by adding persons individually.
&nbsp;     * The method first aggregates the imported data by removing internal duplicates (conflicts)
&nbsp;     * and then compares each aggregated entry with the model. For entries that have the same employeeId
&nbsp;     * as an existing record but with different details (as determined by hasSameDetails), the import is skipped.
&nbsp;     * Both conflict lists (internal conflicts and model conflicts) are returned.
&nbsp;     * if there are EmployeeID prefix conflicts, it is also included in skipped.
&nbsp;     */
&nbsp;    private CommandResult handleAppendMode(Model model, JsonSerializableAddressBook importedData)
&nbsp;            throws CommandException {
&nbsp;        try {
<b class="fc">&nbsp;            List&lt;List&lt;Employee&gt;&gt; importStats = processImportedPersonsWhenAppend(model, importedData);</b>
<b class="fc">&nbsp;            int importedCount = importStats.get(0).size();</b>
<b class="fc">&nbsp;            List&lt;Employee&gt; skippedList = importStats.get(1);</b>
<b class="fc">&nbsp;            int skippedCount = skippedList.size();</b>
<b class="fc">&nbsp;            String skippedDetails = buildConflictErrorMessage(skippedList);</b>
<b class="fc">&nbsp;            return new CommandResult(String.format(MESSAGE_SUCCESS_APPEND,</b>
<b class="fc">&nbsp;                    importedCount, skippedCount, skippedDetails));</b>
<b class="nc">&nbsp;        } catch (IllegalValueException e) {</b>
<b class="nc">&nbsp;            throw new CommandException(String.format(MESSAGE_INVALID_DATA, e.getMessage()));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Processes the imported data in append mode.
&nbsp;     * First, it aggregates the imported employees by removing internal duplicates
&nbsp;     * (i.e. those with the same employeeId but differing PersonKey details).
&nbsp;     * Then, for each aggregated employee, it checks for a conflict with the model:
&nbsp;     * if the model already contains a employee with the same employeeId but different details,
&nbsp;     * the imported employee is flagged as a conflict.
&nbsp;     * Returns a list of two lists:
&nbsp;     * - index 0: employees successfully imported (added or merged)
&nbsp;     * - index 1: employees that were skipped due to conflicts.
&nbsp;     * if there are EmployeeID prefix conflicts, it is also included in omitted.
&nbsp;     */
&nbsp;    private List&lt;List&lt;Employee&gt;&gt; processImportedPersonsWhenAppend(Model model,
&nbsp;                                                                  JsonSerializableAddressBook importedData)
&nbsp;            throws IllegalValueException, CommandException {
&nbsp;        // First, remove internal duplicates/conflicts from the imported data.
<b class="fc">&nbsp;        AggregationResult aggResult = aggregateImportedData(importedData);</b>
<b class="fc">&nbsp;        List&lt;Employee&gt; aggregatedImported = aggResult.aggregated;</b>
&nbsp;        // Start with the internal conflicts as already omitted.
<b class="fc">&nbsp;        List&lt;Employee&gt; omittedEmployees = new ArrayList&lt;&gt;(aggResult.conflicts);</b>
<b class="fc">&nbsp;        List&lt;Employee&gt; importedEmployees = new ArrayList&lt;&gt;();</b>
&nbsp;
&nbsp;        // Now check each aggregated employee against the model.
<b class="fc">&nbsp;        for (Employee employeeToImport : aggregatedImported) {</b>
<b class="fc">&nbsp;            Employee matchInModel = model.getFullFilteredByEmployeeIdPrefixListFromData(</b>
<b class="fc">&nbsp;                            EmployeeId.fromString(employeeToImport.getEmployeeId().toString()))</b>
<b class="fc">&nbsp;                    .stream()</b>
<b class="fc">&nbsp;                    .filter(p -&gt; p.isSameEmployee(employeeToImport))</b>
<b class="fc">&nbsp;                    .findFirst()</b>
<b class="fc">&nbsp;                    .orElse(null);</b>
<b class="fc">&nbsp;            if (matchInModel == null) {</b>
&nbsp;                // No matching employee in model
<b class="fc">&nbsp;                if (model.hasEmployeeIdPrefixConflict(employeeToImport.getEmployeeId())) {</b>
&nbsp;                    // Prefix conflict with existing employee in model.
<b class="fc">&nbsp;                    omittedEmployees.add(employeeToImport);</b>
<b class="fc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;                // No conflict in prefix – add new record.
<b class="fc">&nbsp;                model.addEmployee(employeeToImport);</b>
<b class="fc">&nbsp;                importedEmployees.add(employeeToImport);</b>
<b class="fc">&nbsp;            } else if (matchInModel.hasSameDetails(employeeToImport)) {</b>
&nbsp;                // Matching employee exists with same details – merge anniversary lists.
<b class="fc">&nbsp;                mergeAnniversaries(matchInModel, employeeToImport);</b>
<b class="fc">&nbsp;                importedEmployees.add(employeeToImport);</b>
&nbsp;            } else {
&nbsp;                // Conflict with an existing model record.
<b class="fc">&nbsp;                omittedEmployees.add(employeeToImport);</b>
&nbsp;            }
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;        return List.of(importedEmployees, omittedEmployees);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Aggregates the imported data by grouping by employeeId.
&nbsp;     * For a given employeeId, if all records have the same PersonKey (i.e. same details), they are merged
&nbsp;     * (their anniversaries are combined). Otherwise, if conflicting details are found for the same employeeId,
&nbsp;     * none are aggregated and all are flagged as internal conflicts.
&nbsp;     *
&nbsp;     * @return an AggregationResult containing:
&nbsp;     *          - aggregated: a list of valid Employee objects ready for import.
&nbsp;     *          - conflicts: a list of Employee objects that were removed due to conflicting details.
&nbsp;     */
&nbsp;    private AggregationResult aggregateImportedData(JsonSerializableAddressBook importedData)
&nbsp;            throws IllegalValueException {
<b class="fc">&nbsp;        Map&lt;EmployeeId, Employee&gt; aggregated = new HashMap&lt;&gt;();</b>
&nbsp;        // For employeeIds that have conflicts, we use a set to record all differing PersonKeys.
<b class="fc">&nbsp;        Set&lt;EmployeeId&gt; conflictEmployeeIds = new HashSet&lt;&gt;();</b>
&nbsp;
<b class="fc">&nbsp;        for (JsonAdaptedPerson adapted : importedData.getPersons()) {</b>
<b class="fc">&nbsp;            Employee employee = adapted.toModelType();</b>
<b class="fc">&nbsp;            EmployeeId employeeId = employee.getEmployeeId();</b>
<b class="fc">&nbsp;            PersonKey key = PersonKey.from(adapted);</b>
<b class="fc">&nbsp;            if (aggregated.containsKey(employeeId)) {</b>
<b class="fc">&nbsp;                Employee existing = aggregated.get(employeeId);</b>
<b class="fc">&nbsp;                PersonKey existingKey = PersonKey.from(existing);</b>
<b class="pc">&nbsp;                if (!existingKey.equals(key)) {</b>
&nbsp;                    // Conflict: remove any previously aggregated employee with this employeeId.
<b class="fc">&nbsp;                    conflictEmployeeIds.add(employeeId);</b>
&nbsp;                } else {
&nbsp;                    // Same details: merge anniversary lists.
<b class="nc">&nbsp;                    mergeAnniversaries(existing, employee);</b>
&nbsp;                }
<b class="pc">&nbsp;            } else if (conflictEmployeeIds.contains(employeeId)) {</b>
&nbsp;                // Already flagged as conflict; do nothing.
<b class="nc">&nbsp;                continue;</b>
&nbsp;            } else {
<b class="fc">&nbsp;                aggregated.put(employeeId, employee);</b>
&nbsp;            }
<b class="fc">&nbsp;        }</b>
&nbsp;
&nbsp;        // Build conflict list: all adapted persons whose employeeId is flagged as conflicting.
<b class="fc">&nbsp;        List&lt;Employee&gt; conflicts = importedData.getPersons().stream()</b>
<b class="fc">&nbsp;                .map(adapted -&gt; {</b>
&nbsp;                    try {
<b class="fc">&nbsp;                        return adapted.toModelType();</b>
<b class="nc">&nbsp;                    } catch (IllegalValueException e) {</b>
&nbsp;                        // In case of conversion error, wrap it in a runtime exception.
<b class="nc">&nbsp;                        throw new RuntimeException(e);</b>
&nbsp;                    }
&nbsp;                })
<b class="fc">&nbsp;                .filter(person -&gt; conflictEmployeeIds.contains(person.getEmployeeId()))</b>
<b class="fc">&nbsp;                .collect(Collectors.toList());</b>
&nbsp;
<b class="fc">&nbsp;        return new AggregationResult(new ArrayList&lt;&gt;(aggregated.values()), conflicts);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Merges the anniversaries from the source employee into the target employee.
&nbsp;     */
&nbsp;    private void mergeAnniversaries(Employee target, Employee source) {
<b class="fc">&nbsp;        target.getAnniversaries().addAll(source.getAnniversaries());</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Builds an error message listing the full details of persons that have conflicting records.
&nbsp;     */
&nbsp;    private String buildConflictErrorMessage(List&lt;Employee&gt; conflictEmployees) {
<b class="fc">&nbsp;        return conflictEmployees.stream()</b>
<b class="fc">&nbsp;                .map(this::formatPersonDetails)</b>
<b class="fc">&nbsp;                .collect(Collectors.joining(&quot;\n&quot;, &quot;Conflicting records found:\n&quot;, &quot;&quot;));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Formats the details of a Employee into a readable string.
&nbsp;     */
&nbsp;    private String formatPersonDetails(Employee employee) {
<b class="fc">&nbsp;        return String.format(&quot;Name: %s, Phone: %s, Email: %s, Job Position: %s, EmployeeID: %s, Tags: %s&quot;,</b>
<b class="fc">&nbsp;                employee.getName(), employee.getPhone(), employee.getEmail(), employee.getJobPosition(),</b>
<b class="fc">&nbsp;                employee.getEmployeeId().toString(), employee.getTags().toString());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A helper class to hold the result of aggregating imported persons.
&nbsp;     * Contains a list of aggregated persons (with internal duplicates merged) and
&nbsp;     * a list of persons that were removed due to internal conflicts.
&nbsp;     */
&nbsp;    private static class AggregationResult {
&nbsp;        final List&lt;Employee&gt; aggregated;
&nbsp;        final List&lt;Employee&gt; conflicts;
&nbsp;
<b class="fc">&nbsp;        AggregationResult(List&lt;Employee&gt; aggregated, List&lt;Employee&gt; conflicts) {</b>
<b class="fc">&nbsp;            this.aggregated = aggregated;</b>
<b class="fc">&nbsp;            this.conflicts = conflicts;</b>
<b class="fc">&nbsp;        }</b>
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2025-04-03 01:00</div>
</div>
</body>
</html>
